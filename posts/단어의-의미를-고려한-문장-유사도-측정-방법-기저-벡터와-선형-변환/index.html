<!DOCTYPE html><html lang="kr" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="단어의 의미를 고려한 문장 유사도 측정 방법 - 기저 벡터와 선형 변환" /><meta property="og:locale" content="kr" /><meta name="description" content="Step 1. 문장의 유사도를 구하는 방법" /><meta property="og:description" content="Step 1. 문장의 유사도를 구하는 방법" /><link rel="canonical" href="https://sw-song.github.io/posts/%EB%8B%A8%EC%96%B4%EC%9D%98-%EC%9D%98%EB%AF%B8%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EB%AC%B8%EC%9E%A5-%EC%9C%A0%EC%82%AC%EB%8F%84-%EC%B8%A1%EC%A0%95-%EB%B0%A9%EB%B2%95-%EA%B8%B0%EC%A0%80-%EB%B2%A1%ED%84%B0%EC%99%80-%EC%84%A0%ED%98%95-%EB%B3%80%ED%99%98/" /><meta property="og:url" content="https://sw-song.github.io/posts/%EB%8B%A8%EC%96%B4%EC%9D%98-%EC%9D%98%EB%AF%B8%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EB%AC%B8%EC%9E%A5-%EC%9C%A0%EC%82%AC%EB%8F%84-%EC%B8%A1%EC%A0%95-%EB%B0%A9%EB%B2%95-%EA%B8%B0%EC%A0%80-%EB%B2%A1%ED%84%B0%EC%99%80-%EC%84%A0%ED%98%95-%EB%B3%80%ED%99%98/" /><meta property="og:site_name" content="관성을 이기는 데이터" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-02-11T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="단어의 의미를 고려한 문장 유사도 측정 방법 - 기저 벡터와 선형 변환" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"Step 1. 문장의 유사도를 구하는 방법","headline":"단어의 의미를 고려한 문장 유사도 측정 방법 - 기저 벡터와 선형 변환","dateModified":"2026-01-12T08:03:50+09:00","url":"https://sw-song.github.io/posts/%EB%8B%A8%EC%96%B4%EC%9D%98-%EC%9D%98%EB%AF%B8%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EB%AC%B8%EC%9E%A5-%EC%9C%A0%EC%82%AC%EB%8F%84-%EC%B8%A1%EC%A0%95-%EB%B0%A9%EB%B2%95-%EA%B8%B0%EC%A0%80-%EB%B2%A1%ED%84%B0%EC%99%80-%EC%84%A0%ED%98%95-%EB%B3%80%ED%99%98/","datePublished":"2023-02-11T00:00:00+09:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://sw-song.github.io/posts/%EB%8B%A8%EC%96%B4%EC%9D%98-%EC%9D%98%EB%AF%B8%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EB%AC%B8%EC%9E%A5-%EC%9C%A0%EC%82%AC%EB%8F%84-%EC%B8%A1%EC%A0%95-%EB%B0%A9%EB%B2%95-%EA%B8%B0%EC%A0%80-%EB%B2%A1%ED%84%B0%EC%99%80-%EC%84%A0%ED%98%95-%EB%B3%80%ED%99%98/"},"@context":"https://schema.org"}</script><title>단어의 의미를 고려한 문장 유사도 측정 방법 - 기저 벡터와 선형 변환 | 관성을 이기는 데이터</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="관성을 이기는 데이터"><meta name="application-name" content="관성을 이기는 데이터"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/main/logo.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">관성을 이기는 데이터</a></div><div class="site-subtitle font-italic">Data Analytics and Automation</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/sw-song" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://www.linkedin.com/in/seungwonsong/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sw930601','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>단어의 의미를 고려한 문장 유사도 측정 방법 - 기저 벡터와 선형 변환</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>단어의 의미를 고려한 문장 유사도 측정 방법 - 기저 벡터와 선형 변환</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Seungwon Song </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sat, Feb 11, 2023, 12:00 AM +0900" >Feb 11, 2023<i class="unloaded">2023-02-11T00:00:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Jan 12, 2026, 8:03 AM +0900" >Jan 12<i class="unloaded">2026-01-12T08:03:50+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4544 words">25 min read</span></div></div><div class="post-content"><h3 id="step-1-문장의-유사도를-구하는-방법">Step 1. 문장의 유사도를 구하는 방법</h3><ul><li>두 문서의 유사성은 어떻게 측정할 수 있을까?</ul><p>문장의 길이? 아니면 주어, 동사, 목적어 등의 문법 구조?<br /> 그것보다는 얼마나 공통 ‘단어’를 많이 포함하고 있는가? 가 더 합리적으로 보인다. 실제로 수많은 전통적인 텍스트마이닝 방법론들은 이러한 단어 기반 유사도 측정 방식을 따르며, 현재 딥러닝, AI 시대에도 역시 문장 구조와 속성을 분석할 때 단어는 핵심 요소다.</p><p>이렇게 단어를 기준으로 문장 유사도를 구하기 위해서는 단어를 숫자로 변환해 줄 필요가 있다.<br /> 즉, 유사도 혹은 거리를 수학적으로 계산하기 위해 문장을 일종의 좌표평면 상에 놓을 수 있어야 하고<br /> 문장이 좌표평면에 놓이기 위해서는 문장을 구성하고 있는 단어들을 스칼라 혹은 벡터값으로 변환해줘야 하는 것이다.</p><p>따라서 문장의 유사도를 계산하는 과정은 다음과 같다.</p><ol><li>단어를 숫자(스칼라 혹은 벡터)로 변환<li>각 문장을 벡터(단어)의 배열로 변환<li>문장 벡터간 유사도 계산</ol><h2 id="step-2-빈도-기반-유사도-계산">Step 2. 빈도 기반 유사도 계산</h2><h3 id="2-1-문장별-단어-카운트">2-1. 문장별 단어 카운트</h3><p>먼저 단어를 숫자(스칼라 혹은 벡터)로 변환하는 것부터 시작해보자.</p><p>단어를 숫자로 변환하려면 어떻게 해야 할까?<br /> 가장 쉬운 방법은 각 문장에 단어가 몇 번 등장하는지 세는 것이다.<br /> 먼저 사용할 패키지를 불러온다.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-0.webp" alt="" /></p><p>샘플 문장은 다음과 같다.</p><ul><li>doc_1, doc_2, doc_3은 모두 cake라는 단어를 포함한다.<li>doc_1과 doc_2는 먹는 케이크에 관한 내용이다.<li>doc_3은 케이크라는 영화에 관한 내용이다.</ul><p><img data-proofer-ignore data-src="/assets/images/posts/134-1.webp" alt="" /></p><p>단어 수를 세기 위해 sklearn의 CounterVectorizer를 활용한다.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-2.webp" alt="" /></p><p>CounterVectorizer에 인자로 stop_words를 줄 수 있다.<br /> stop_words는 제외할 단어들을 설정하는 것이며 ‘english’를 지정해주면 영어 문장에서 빈번하게 등장하는 This, That, What, a, is 등의 단어들을 제거해준다.</p><p>이것의 효용은 문장의 특성을 강화시켜 주는 데에 있다.<br /> CounterVectorizer를 사용해 얻은 단어 메트릭스는 일종의 단어사전인데, 우리의 단어사전이 어떤 문장에서나 보이는 단어들도 모두 포함하게 되면 사전의 크기는 매우 커지고 주요 단어들의 정보량이 희석된다.<br /> 따라서 공통적으로 어떤 문장에서나 보이는 단어들보다는 특정 문장의 특성을 잘 보여주는 단어들을 중심으로 사전을 구성하려는 것이다.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-3.webp" alt="" /></p><p>단어사전이 가지게 된 단어는 총 4개다.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-4.webp" alt="" /></p><p>doc_1, doc_2, doc_3 각각 포함하는 단어 빈도를 표시해주면 다음과 같다.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-5.webp" alt="" /></p><h3 id="2-2-문장-벡터-시각화">2-2. 문장 벡터 시각화</h3><p>단어 빈도로 구성된 doc_1, doc_2, doc_3는 이제 각각 하나의 벡터로 생각해보자.<br /> 그렇다면 해당 벡터는 4차원 공간에 표시할 수 있고, 4차원 좌표평면을 그리기는 어렵기 때문에 cake, movie, tasty 3개 단어를 x, y, z 축으로 해서 문장 벡터를 시각화해 보도록 하자.</p><p>그전에, 각 문장 내용을 인덱싱 해서 쉽게 볼 수 있도록 Dictionary를 하나 만들어주자.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-6.webp" alt="" /></p><p>이렇게 각 문장을 3차원 좌표평면상에 위치시켜보자.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-7.webp" alt="" /></p><h3 id="2-3-문장-벡터-간-유사도-계산">2-3. 문장 벡터 간 유사도 계산</h3><p>벡터간 유사도를 계산하기 위한 방법으로는 주로 점 간의 직경 거리를 계산하는 ‘유클리디안 거리’, 각 벡터간 코사인 각도를 비교하는 ‘코사인 유사도’가 대표적이다. 참고로 벡터변환을 하지 않고 문장 내 공통 단어의 비율(동시출현빈도)을 보는 ‘자카드 유사도’도 가벼운 추천시스템 등에 자주 쓰이나 여기서는 다루지 않겠다.</p><ul><li>유클리디안 거리는 numpy에서 제공하는 선형대수를 위한 함수 linarg를 사용해 벡터 길이 즉 노름(norm)을 계산함으로써 얻을 수 있다.</ul><p><img data-proofer-ignore data-src="/assets/images/posts/134-8.webp" alt="" /></p><ul><li>다음으로 코사인 유사도는 두 벡터의 스칼라곱을 각 벡터 길이의 곱으로 나눠줌으로써 계산할 수 있다.<li>np.dot(vector_1, vector_2)를 통해 스칼라곱을 구하고, np.linalg.norm(vector_1) * np.linalg.norm(vector_2)를 통해 각 벡터 길이의 곱을 구한다.<li>마지막으로 주의할 점은 유클리디언 거리와 동일하게 ‘벡터간 차이’를 기준으로 잡기 위하여 ‘1-유사도’를 계산여 ‘얼마나 유사하지 않은가’를 확인하도록 하겠다. 이를 편의상 이하 ‘코사인 거리’로 명명하도록 하자.</ul><p><img data-proofer-ignore data-src="/assets/images/posts/134-9.webp" alt="" /></p><p>doc_1과 doc_2, 그리고 doc_2와 doc_3은 유클리디안 거리가 서로 1.73으로 동일하며 코사인 거리 역시 0.37로 동일하다.</p><p>다시 말해 doc_1과 doc_2은 케이크에 대해 이야기하고 있고, doc_3은 영화에 대한 문장인데도 불구하고 doc_2이 doc_1, doc_3과의 유사도가 같다는 것이다. 뭔가 문제가 있어 보인다.</p><p>이 문제를 조금 더 극대화해보자.</p><h2 id="step-3-코사인-유사도의-효용">Step 3. 코사인 유사도의 효용</h2><p>그럼, 거리 기반 유사도(유클리디안)와 각도 기반 유사도(코사인) 방식은 계산 효용에 차이가 없는가?<br /> 그렇지 않다. 만약 문장의 길이가 길어져 단어 빈도가 늘어난다면 유클리디안 방식은 문장의 유사도를 계산하는 데에 있어서 효용을 급격히 잃게 된다.</p><h3 id="3-1-단어가-반복-등장하는-예">3-1. 단어가 반복 등장하는 예</h3><p>예로, doc_1을 5번 반복해보자.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-10.webp" alt="" /></p><p>그리고 앞에서 한 것과 동일하게 각 문장별 단어 빈도 테이블을 생성해주자.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-11.webp" alt="" /></p><p>각 문장은 다음과 같다. doc_1이 다소 극단적인 예시처럼 보이지만 노래가사, 시, 광고문구 등을 떠올려보면 현실에서 문서 내에 특정 단어나 문장이 반복되는 경우는 매우 흔하다.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-12.webp" alt="" /></p><h3 id="3-2-문장-벡터-시각화">3-2. 문장 벡터 시각화</h3><p>doc_1은 단어를 반복시켰고, doc_2와 doc_3은 그대로다. 좌표평면상에 3개의 문장을 표시해보자.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-13.webp" alt="" /></p><h3 id="3-3-문장-벡터-간-유사도-계산">3-3. 문장 벡터 간 유사도 계산</h3><p>이제 유클리디안 거리, 코사인 거리를 수치로 확인해보자.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-14.webp" alt="" /></p><ul><li>doc_1과 doc_2의 유클리디안 거리는 5.92, 코사인 거리는 0.37이다.<li>doc_2와 doc_3의 유클리디안 거리는 1.73, 코사인 거리는 0.37이다.</ul><p>doc_1과 doc_2는 먹는 케이크에 대한 내용, doc_3은 영화 제목에 대한 내용임에도 doc_1의 문장이 길어짐으로써(정확히는 단어가 반복되면서) doc_2와의 직경 거리가 더 멀어졌다. 반대로 벡터의 길이가 아무리 길어졌어도 doc_1과 doc_2, 그리고 doc_2와 doc_3의 코사인 거리는 동일하게 보존되고 있다.</p><p>이를 통해 유클리디안 거리는 문장 크기에 강한 영향을 받으며 코사인 거리는 문장 크기로부터 자유롭다는 것을 확인했다.</p><h2 id="step-4-선형-변환을-통한-의미상-유사도-계산">Step 4. 선형 변환을 통한 의미상 유사도 계산</h2><p>다시 문장의 길이를 늘리기 전 상황으로 돌아가보자.</p><p>doc_1과 doc_2의 토픽은 케이크, doc_2의 토픽은 영화다. 그렇다면 doc_1과 doc_2의 유사도는 doc_2와 doc_2의 유사도보다 높아야 한다. 즉, 거리가 더 짧아야 한다. 그러나 doc_1과 doc_2, 그리고 doc_2와 doc_3의 거리는 동일하다.(유클리디안, 코사인 방식 모두.)</p><p>그렇다면 의미가 유사한 doc_1과 doc_2는 더 가깝게, doc_3은 조금 더 멀리 떨어뜨릴 순 없을까?</p><p>방법은 좌표계를 바꾸는 것이다. 잠깐 생각해보면, 우리는 좌표평면의 축에 대해서 고려하지 않았다. 좌표평면 축은 각각 ‘movie’, ‘cake’, ‘tasty’의 빈도 수를 나타내며 이에 대해 암묵적으로 좌표계상 기저를 (0,0,1), (0,1,0), (1,0,0)으로 고정시킨 것이다.</p><p>이 기저를 선형변환해서 좌표계를 찌그러뜨린다면 doc_1, doc_2, doc_3의 벡터도 기저에 따라 선형변환하며 doc_1과 doc_2는 가깝게, doc_3은 멀게 위치시킬 수 있다.</p><h3 id="4-1-단어에-의미를-부여하는-워드임베딩">4-1. 단어에 의미를 부여하는 워드임베딩</h3><p>선형변환을 하기 위해서는 기저벡터를 먼저 구해야 한다. 즉, 문장이 위치할 좌표평면상 축을 구성하는 ‘movie’, ‘cake’, ‘tasty’가 각각 어디에 위치하는지, 축의 위치를 잡는 것이다.</p><p>이를 위해서는 ‘movie’, ‘cake’, ‘tasty’에 대한 벡터 값이 있어야 하는데, 이를 구하기 위해서 단어임베딩 모델을 사용할 수 있다. 단어임베딩은 위키피디아 같은 방대한 텍스트에서 문장들을 추출하고, 각 문장 내 단어의 위치관계를 학습해 각 단어마다의 의미를 벡터로 정의하는 방식이다. 앞서 우리가 간단히 빈도로 구성한 단어사전이 각 단어마다 정수 형태의 scalar 값을 가졌다면, 단어임베딩의 결과물인 밀집 단어사전은 각 단어가 수백 차원의 밀집벡터(정수가 아닌 -1에서 1 사이로 압축된 실수 형태)라고 생각하면 된다.</p><p>이미 수많은 언어모델이 공개되어 있고 언어모델은 반드시 텍스트를 벡터로 변환하는 토크나이저를 포함하므로 이러한 토크나이저의 근간이 되는 학습된 단어임베딩 모델을 쉽게 가져다 사용할 수 있다. 참고로 단어임베딩 모델은 각 테스크에 특화되어 있는 것이 일반적이다. 예를 들어 위키피디아를 학습한 단어임베딩 모델이 가지고 있는 단어사전은 뉴스를 학습한 단어임베딩 모델이 가지고 있는 단어사전과 다르다.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-15.webp" alt="" /></p><p>전통적으로 word2vec 모델이 많이 쓰이는데, word2vec 모델은 쪼갤 수 있는 최소 단위를 말 그대로 ‘단어’로 한다. 반면 페이스북에서 이를 더 작은 글자(text) 단위로 학습할 수 있도록 개량한 모델이 fasttext다. fasttext의 강점은 학습 모델이 ‘truelove’ 같은 단어를 본 적이 없다 하더라도 ‘true’, ‘love’를 각각 경험했다면 ‘truelove’를 ‘love’와 가까운 단어로 인식하고 계산할 수 있다는 것이다.</p><p>본 실습에서도 fasttext를 사용하며, 영문 단어임베딩에 대표적으로 많이 쓰이는 ‘fasttext-wiki-news-subwords-300’ 모델을 빌려와 사용하도록 하겠다.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-16.webp" alt="" /></p><p>지금부터 fasttext를 단어사전이라 생각하자. movie를 사전에서 검색해보면 다음과 같은 결과가 나온다.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-17.webp" alt="" /></p><p>단어사전에서 꺼낸 movie는 300차원짜리 벡터다.<br /> 이는 앞에서 우리가 movie에 어떠한 의미도 주지 않고 (0,1,0)의 3차원 기저벡터로 설정했던 것과 비교된다.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-18.webp" alt="" /></p><p>movie와 비슷한 단어 10개를 다음과 같이 사전에서 검색할 수 있다.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-19.webp" alt="" /></p><p>movie와 가장 비슷한 flim과의 유사도를 보면 0.876~이다. 이는 코사인 유사도인데, 앞에서 우리가 만든 코사인 거리 함수로 같은 값을 도출할 수 있다.<br /> 코사인 거리 함수의 출력값은 ‘1-유사도’ 이므로 아래 결괏값에서 1-dst를 해주면 0.876~이 나온다는 것을 이해할 수 있다.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-20.webp" alt="" /></p><p>물론 fasttext를 사용해 거리도 계산할 수 있다. 마찬가지로 결괏값은 1-유사도다.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-21.webp" alt="" /></p><p>이제 우리 좌표평면상 기저벡터인 cake, tasty, movie의 서로간 거리를 살펴보자.<br /> 기존에 임의로 설정한 기저를 기준으로 하면 거리는 모두 동일해야 하지만 현재 임베딩된 값으로 비교했을 때는 차이가 있다.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-22.webp" alt="" /></p><p>cake와 tasty의 코사인 거리는 0.5인 반면 movie와 cake, movie와 tasty는 각각 0.69, 0.67로 의미상 거리가 더 멀다는 것을 확인할 수 있다.</p><p>그런데 아쉽게도 우리는 300차원짜리 단어 벡터로는 좌표계를 그릴 수 없다. 적어도 3차원으로는 바꿔줘야 한다.</p><h3 id="4-2-pca차원축소">4-2. PCA(차원축소)</h3><p>다행히 우리는 비지도학습 기반 차원축소 기법을 사용할 수 있다. 차원축소는 다차원 데이터를 더 작은 데이터로 압축하는 방법이며, 데이터가 가지고 있는 본연의 특성을 최대한 유지하면서 변수를 줄일 수 있다. 물론, 300차원을 3차원으로 축소하게 되면 그만큼 정보손실이 발생한다. 그러나 우리는 머신러닝 모델링이 아니라 단순히 3차원 좌표계로 문서 간 거리를 확인하고자 함이므로 정보손실을 감수하고 차원을 줄이도록 하겠다.</p><p>차원 축소를 위해서 ‘movie’, ‘cake’, ‘tasty’ 3가지 값을 포함해 관련 단어들을 각 단어당 200개씩 추출해서 데이터를 구성하겠다. 이렇게 하는 이유는 ‘movie’, ‘cake’, ‘tasty’ 각 단어의 유사 군집을 함께 비지도학습 시킴으로써 상대적으로 3개 단어의 위치정보를 인지시키기 위함이다. 이렇게 했을 때 큰 정보손실에도 고유의 군집 특성을 남길 수 있다.</p><ul><li>먼저, 연관 단어를 추출한다.</ul><p><img data-proofer-ignore data-src="/assets/images/posts/134-23.webp" alt="" /></p><ul><li>모든 단어에 대한 300차원의 벡터 값을 가져온다.</ul><p><img data-proofer-ignore data-src="/assets/images/posts/134-24.webp" alt="" /></p><ul><li>그러면 메트릭스는 603개 단어에 대한 300차원 벡터로 구성된다.</ul><p><img data-proofer-ignore data-src="/assets/images/posts/134-25.webp" alt="" /></p><ul><li>PCA 모델은 sklearn 패키지에서 제공한다.<li>n_components 파라미터를 통해 축소할 차원을 3차원으로 설정하고, 결과값을 데이터프레임으로 생성해준다.</ul><p><img data-proofer-ignore data-src="/assets/images/posts/134-26.webp" alt="" /></p><p>압축된 차원의 데이터분포상 범위는 다음과 같다.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-27.webp" alt="" /></p><h3 id="4-3-기저-벡터-및-문장-벡터-시각화">4-3. 기저 벡터 및 문장 벡터 시각화</h3><ul><li>이제 기저 벡터에 대한 3차원 값을 확인할 수 있다.<li>기저 벡터를 선으로 그리고, 기존 문장 벡터는 기저 벡터에 따라 선형 변환시킨 다음 좌표계에 찍어보도록 하자.</ul><p><img data-proofer-ignore data-src="/assets/images/posts/134-28.webp" alt="" /></p><p>기저 벡터가 기존에 (1,0,0), (0,1,0), (0,0,1)이었다면 지금은 (-0.49, 0.19, 0.38), (0.59, 0.55, 0.22), (0.40, -0.39, 0.35)로 선형 변환되었다.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-29.webp" alt="" /></p><p>선형 변환된 기저 벡터에 따라 문서 벡터 역시 선형 변환시켰다. 선형 변환은 다음과 같이 행렬곱을 통해 수행할 수 있다.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-30.webp" alt="" /></p><p>마지막으로, 기저 벡터의 방향에 따라 3차원 좌표계 축을 다시 그리고 좌표계상 문서 벡터의 끝점 위치를 찍어보자.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-31.webp" alt="" /></p><p>축의 각도와 각 문서 벡터 끝점(doc_1, doc_2, doc_3)의 위치가 바뀐 것을 더 명확히 확인할 수 있다.</p><h3 id="4-4-문장-벡터-간-유사도-계산">4-4. 문장 벡터 간 유사도 계산</h3><p>시각화했던 코드에서 다음과 같이 변수를 만들어 주었다. 위에서도 확인한 값이지만, df_doc_trans_pos는 선형 변환된 문장 벡터의 끝점 위치를 보여준다.<br /> 이제 선형 변환시킨 문장 벡터의 코사인 거리가 어떻게 바뀌었을지 확인해보자.</p><p><img data-proofer-ignore data-src="/assets/images/posts/134-32.webp" alt="" /></p><p><img data-proofer-ignore data-src="/assets/images/posts/134-33.webp" alt="" /></p><ul><li>doc_1과 doc_2의 유클리디안 거리는 0.98, 코사인 거리는 0.18이다.<li>doc_2와 doc_3의 유클리디안 거리는 1.16, 코사인 거리는 0.26이다.</ul><p>다시 정리하면, doc_1과 doc_2는 먹는 케이크에 대한 내용, doc_3은 영화 제목에 대한 내용이었다. 그리고 선형 변환 전에는 doc_1과 doc_2, doc_2와 doc_3간의 유클리디언 거리 및 코사인 거리가 서로 동일했다.</p><p>그러나 기저 벡터의 선형 변환에 따라 좌표계가 바뀐 뒤에는 doc_1과 doc_2간의 거리가 doc_2와 doc_3간의 거리보다 유클리디안, 코사인 방식 모두에서 더 짧아졌다.</p><p>지금까지 문장의 유사도를 구하는 방법에 대해 알아보았다.<br /> 그 과정에서 코사인 유사도의 유클리디안 거리 계산 방식 대비 효용, 그리고 단어와 문장을 벡터로 변환하는 방법들을 확인했고, 더 나아가 기저 벡터의 선형 변환 및 좌표계 수정을 통해 문장의 의미를 고려한 유사도 계산 방법에 대해서도 확인해보았다.</p><p><strong>관성을 이기는 데이터</strong></p><p><a href="https://creativecommons.org/licenses/by/4.0/deed.ko">저작자표시 (새창열림)</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/1-%EA%B8%B0%EC%88%A0/'>1. 기술</a>, <a href='/categories/%EC%84%9C%EB%B2%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%81%B4%EB%9D%BC%EC%9A%B0%EB%93%9C/'>서버, 데이터, 클라우드</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=단어의 의미를 고려한 문장 유사도 측정 방법 - 기저 벡터와 선형 변환 - 관성을 이기는 데이터&url=https://sw-song.github.io/posts/%EB%8B%A8%EC%96%B4%EC%9D%98-%EC%9D%98%EB%AF%B8%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EB%AC%B8%EC%9E%A5-%EC%9C%A0%EC%82%AC%EB%8F%84-%EC%B8%A1%EC%A0%95-%EB%B0%A9%EB%B2%95-%EA%B8%B0%EC%A0%80-%EB%B2%A1%ED%84%B0%EC%99%80-%EC%84%A0%ED%98%95-%EB%B3%80%ED%99%98/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=단어의 의미를 고려한 문장 유사도 측정 방법 - 기저 벡터와 선형 변환 - 관성을 이기는 데이터&u=https://sw-song.github.io/posts/%EB%8B%A8%EC%96%B4%EC%9D%98-%EC%9D%98%EB%AF%B8%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EB%AC%B8%EC%9E%A5-%EC%9C%A0%EC%82%AC%EB%8F%84-%EC%B8%A1%EC%A0%95-%EB%B0%A9%EB%B2%95-%EA%B8%B0%EC%A0%80-%EB%B2%A1%ED%84%B0%EC%99%80-%EC%84%A0%ED%98%95-%EB%B3%80%ED%99%98/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=단어의 의미를 고려한 문장 유사도 측정 방법 - 기저 벡터와 선형 변환 - 관성을 이기는 데이터&url=https://sw-song.github.io/posts/%EB%8B%A8%EC%96%B4%EC%9D%98-%EC%9D%98%EB%AF%B8%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EB%AC%B8%EC%9E%A5-%EC%9C%A0%EC%82%AC%EB%8F%84-%EC%B8%A1%EC%A0%95-%EB%B0%A9%EB%B2%95-%EA%B8%B0%EC%A0%80-%EB%B2%A1%ED%84%B0%EC%99%80-%EC%84%A0%ED%98%95-%EB%B3%80%ED%99%98/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Tistory%EC%97%90%EC%84%9C-GitHub-Pages%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%88%EC%9D%B4%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%85%98-%EC%99%84%EC%A0%84-%EA%B0%80%EC%9D%B4%EB%93%9C/">Tistory에서 GitHub Pages로 블로그 마이그레이션 완전 가이드</a><li><a href="/posts/JavaScript-%EC%BD%9C%EB%B0%B1/">JavaScript - 콜백</a><li><a href="/posts/JavaScript-%EA%B0%9D%EC%B2%B4-%EC%B0%B8%EC%A1%B0-assign/">JavaScript - '객체 참조', assign()</a><li><a href="/posts/%EB%A7%A5-Mac-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%B2%BD%EB%A1%9C%EC%84%A4%EC%A0%95-%EC%95%84%EB%82%98%EC%BD%98%EB%8B%A4-Anaconda-2020%EB%85%84-5%EC%9B%94-10%EC%9D%BC-%EA%B8%B0%EC%A4%80/">맥(Mac) 터미널 경로설정 - 아나콘다(Anaconda), 2020년 5월 10일 기준 updated</a><li><a href="/posts/%EB%A7%A5-zsh-conda-install-%EC%97%90%EB%9F%AC-pip-install%EB%A1%9C-%EB%8C%80%EC%B2%B4/">맥 zsh - conda install 에러, pip install로 대체</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/Elastic-Search-%EC%99%B8%EB%B6%80-%ED%98%B8%EC%8A%A4%ED%8C%85-%EA%B0%9C%EB%B0%A9/"><div class="card-body"> <span class="timeago small" >May 31, 2022<i class="unloaded">2022-05-31T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Elastic Search - 외부 호스팅 개방</h3><div class="text-muted small"><p> 외부에서 엘라스틱서치 클러스터에 접속하기 위해서는 config/elasticsearch.yml 파일에서 network.host: “_stie_” (혹은 internet-ip) 를 입력해줘야 한다. 그런데, 이렇게 수정하고 실행하면 부트스트랩 에러가 발생한다. 이 부분을 해결하려면 /etc/security/limits.conf 파일과 /etc/...</p></div></div></a></div><div class="card"> <a href="/posts/GCP-VM-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%83%9D%EC%84%B1-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EB%B3%B5%EC%A0%9C/"><div class="card-body"> <span class="timeago small" >May 31, 2022<i class="unloaded">2022-05-31T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>GCP - VM 이미지 생성, 인스턴스 복제</h3><div class="text-muted small"><p> 가상머신 Copy하는법(이미지생성) **VM 인스턴스 탭 -&gt;**이미지 생성 -&gt; 생성된 이미지로 새로운 인스턴스 생성** 관성을 이기는 데이터 저작자표시 (새창열림)</p></div></div></a></div><div class="card"> <a href="/posts/Kibana-%EB%AA%A8%EB%8B%88%ED%84%B0%EB%A7%81-%EB%A9%88%EC%B6%94%EA%B8%B0/"><div class="card-body"> <span class="timeago small" >May 31, 2022<i class="unloaded">2022-05-31T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Kibana - 모니터링 멈추기</h3><div class="text-muted small"><p> 키바나를 elastic search와 연동하여 실행시 default로 실시간 데이터가 적재된다. 만약 테스트를 위한 작은 VM을 띄우고 실습한다면, 용량에 부담을 주고 ssh 서버 접속이 제한될 수 있으니 경우에 따라 제한할 필요가 있다. 실행시 데이터 적재되는 모습 메모리 용량 조절을 위해 모니터링하지 않을때는 데이터가 쌓이지 않도록 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%EB%B2%A1%ED%84%B0%EC%9E%90%EA%B8%B0%ED%9A%8C%EA%B7%80-%EB%AA%A8%ED%98%95-VAR-%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%8B%A4%EB%B3%80%EB%9F%89-%EC%98%88%EC%B8%A1-%EB%AA%A8%EB%8D%B8%EB%A7%81-%EA%B5%AD%EB%82%B4-%EC%A3%BC%EC%9A%94-%EA%B8%B0%EC%97%85-%EC%A3%BC%EA%B0%80-%EB%B0%8F-%EA%B1%B0%EB%9E%98%EB%9F%89/" class="btn btn-outline-primary" prompt="Older"><p>벡터자기회귀 모형(VAR)을 활용한 다변량 예측 모델링 - 국내 주요 기업 주가 및 거래량 예측</p></a> <a href="/posts/TF-IDF-%ED%96%89%EB%A0%AC%EC%9D%98-%ED%8A%B9%EC%9D%B4%EA%B0%92-%EB%B6%84%ED%95%B4%EB%A5%BC-%ED%86%B5%ED%95%9C-LSA-Latent-Semantic-Analysis/" class="btn btn-outline-primary" prompt="Newer"><p>TF-IDF 행렬의 특이값 분해를 통한 LSA(Latent Semantic Analysis)의 구현과 빈도 기반 토픽 모델의 한계</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://github.com/sw-song">Seungwon Song</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
