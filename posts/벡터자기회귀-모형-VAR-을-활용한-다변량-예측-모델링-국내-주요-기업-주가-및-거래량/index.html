<!DOCTYPE html><html lang="kr" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="days ago"><meta name="hour-prompt" content="hours ago"><meta name="minute-prompt" content="minutes ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="벡터자기회귀 모형(VAR)을 활용한 다변량 예측 모델링 - 국내 주요 기업 주가 및 거래량 예측" /><meta property="og:locale" content="kr" /><meta name="description" content="Step 1. VAR 이란?" /><meta property="og:description" content="Step 1. VAR 이란?" /><link rel="canonical" href="https://sw-song.github.io/posts/%EB%B2%A1%ED%84%B0%EC%9E%90%EA%B8%B0%ED%9A%8C%EA%B7%80-%EB%AA%A8%ED%98%95-VAR-%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%8B%A4%EB%B3%80%EB%9F%89-%EC%98%88%EC%B8%A1-%EB%AA%A8%EB%8D%B8%EB%A7%81-%EA%B5%AD%EB%82%B4-%EC%A3%BC%EC%9A%94-%EA%B8%B0%EC%97%85-%EC%A3%BC%EA%B0%80-%EB%B0%8F-%EA%B1%B0%EB%9E%98%EB%9F%89/" /><meta property="og:url" content="https://sw-song.github.io/posts/%EB%B2%A1%ED%84%B0%EC%9E%90%EA%B8%B0%ED%9A%8C%EA%B7%80-%EB%AA%A8%ED%98%95-VAR-%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%8B%A4%EB%B3%80%EB%9F%89-%EC%98%88%EC%B8%A1-%EB%AA%A8%EB%8D%B8%EB%A7%81-%EA%B5%AD%EB%82%B4-%EC%A3%BC%EC%9A%94-%EA%B8%B0%EC%97%85-%EC%A3%BC%EA%B0%80-%EB%B0%8F-%EA%B1%B0%EB%9E%98%EB%9F%89/" /><meta property="og:site_name" content="관성을 이기는 데이터" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-02-08T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="벡터자기회귀 모형(VAR)을 활용한 다변량 예측 모델링 - 국내 주요 기업 주가 및 거래량 예측" /><meta name="twitter:site" content="@twitter_username" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"Step 1. VAR 이란?","headline":"벡터자기회귀 모형(VAR)을 활용한 다변량 예측 모델링 - 국내 주요 기업 주가 및 거래량 예측","dateModified":"2026-01-12T08:03:50+09:00","url":"https://sw-song.github.io/posts/%EB%B2%A1%ED%84%B0%EC%9E%90%EA%B8%B0%ED%9A%8C%EA%B7%80-%EB%AA%A8%ED%98%95-VAR-%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%8B%A4%EB%B3%80%EB%9F%89-%EC%98%88%EC%B8%A1-%EB%AA%A8%EB%8D%B8%EB%A7%81-%EA%B5%AD%EB%82%B4-%EC%A3%BC%EC%9A%94-%EA%B8%B0%EC%97%85-%EC%A3%BC%EA%B0%80-%EB%B0%8F-%EA%B1%B0%EB%9E%98%EB%9F%89/","datePublished":"2023-02-08T00:00:00+09:00","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://sw-song.github.io/posts/%EB%B2%A1%ED%84%B0%EC%9E%90%EA%B8%B0%ED%9A%8C%EA%B7%80-%EB%AA%A8%ED%98%95-VAR-%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%8B%A4%EB%B3%80%EB%9F%89-%EC%98%88%EC%B8%A1-%EB%AA%A8%EB%8D%B8%EB%A7%81-%EA%B5%AD%EB%82%B4-%EC%A3%BC%EC%9A%94-%EA%B8%B0%EC%97%85-%EC%A3%BC%EA%B0%80-%EB%B0%8F-%EA%B1%B0%EB%9E%98%EB%9F%89/"},"@context":"https://schema.org"}</script><title>벡터자기회귀 모형(VAR)을 활용한 다변량 예측 모델링 - 국내 주요 기업 주가 및 거래량 예측 | 관성을 이기는 데이터</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="관성을 이기는 데이터"><meta name="application-name" content="관성을 이기는 데이터"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang="en"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/main/logo.png" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">관성을 이기는 데이터</a></div><div class="site-subtitle font-italic">Data Analytics and Automation</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center"> <a href="https://github.com/sw-song" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github"></i> </a> <a href="https://www.linkedin.com/in/seungwonsong/" aria-label="linkedin" target="_blank" rel="noopener"> <i class="fab fa-linkedin"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sw930601','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>벡터자기회귀 모형(VAR)을 활용한 다변량 예측 모델링 - 국내 주요 기업 주가 및 거래량 예측</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>벡터자기회귀 모형(VAR)을 활용한 다변량 예측 모델링 - 국내 주요 기업 주가 및 거래량 예측</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Seungwon Song </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Feb 8, 2023, 12:00 AM +0900" >Feb 8, 2023<i class="unloaded">2023-02-08T00:00:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Jan 12, 2026, 8:03 AM +0900" >Jan 12<i class="unloaded">2026-01-12T08:03:50+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="4592 words">25 min read</span></div></div><div class="post-content"><h2 id="step-1-var-이란">Step 1. VAR 이란?</h2><p>VAR이란 Vector Autoregression, 벡터자기회귀 모형을 의미한다. 기본적인 자기회귀모형이 단변량 시계열 예측에서 사용된다면 벡터자기회귀모형은 다변량 예측에 사용된다. 즉, 2개 이상의 같은 기간에 대한 데이터셋이 서로 다른 변수로 서로 영향을 주는 관계인 경우 벡터자기회귀 모형을 사용한다.</p><p>단변량 예측에 사용되는 자기회귀 모형 AR, ARMA, ARIMA의 경우 특정 시점의 과거가 현재에 영향을 미치는 단방향 모형일 수 밖에 없다. 이와 달리 VAR은 각 시계열 변수가 서로 영향을 주며 이를 고려해 각 변수의 미래값을 전체 시계열 변수의 과거값으로부터 예측하므로 양방향 모형이다. 이러한 방향성은 변수간 관게를 보여주는 것이기도 하다.(VAR의 인자로 주어지는 변수들은 서로 영향을 주고 받는다.)</p><h2 id="step-2-데이터셋-준비">Step 2. 데이터셋 준비</h2><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre>import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# MacOS - 한글 폰트
from matplotlib import rc
rc('font', family='AppleGothic')
plt.rcParams['axes.unicode_minus'] = False

# Graph Style
import mplcyberpunk
plt.style.use('cyberpunk')

# Ignore Warnings
import warnings
warnings.filterwarnings('ignore')
</pre></table></code></div></div><p>2010년~2022년까지의 카카오, 네이버, 삼성전자, 하이닉스 주가 정보를 불러온다.</p><p><img data-proofer-ignore data-src="/assets/images/posts/133-0.webp" alt="" /> <img data-proofer-ignore data-src="/assets/images/posts/133-1.webp" alt="" /> <img data-proofer-ignore data-src="/assets/images/posts/133-2.webp" alt="" /></p><p>카카오, 네이버, 삼성, 하이닉스 주가 정보 중 수정주가와 거래량만 가져온다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>df = pd.concat([
    yf_kakao[['Adj Close', 'Volume']],
    yf_naver[['Adj Close', 'Volume']],
    yf_samsung[['Adj Close', 'Volume']],
    yf_skhy[['Adj Close', 'Volume']],], axis=1)

df.columns = [
    'kakao_ac', 'kakao_v', 
    'naver_ac', 'naver_v', 
    'samsung_ac', 'samsung_v', 
    'skhy_ac', 'skhy_v'
]
df
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-3.webp" alt="" /></p><p>가져온 데이터는 다음과 같이 시각화해볼 수 있다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre>fig, axes = plt.subplots(nrows=4, ncols=2, figsize=(15,6))

ax_li = axes.flatten()
df_cols = df.columns
for i, (col, ax) in enumerate(zip(df_cols, ax_li)):
    ax.plot(df[col], linewidth=0.8)
    ax.set_title(col)

plt.tight_layout()
plt.show()
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-4.webp" alt="" /></p><p>우선, 수정주가를 보면 카카오와 네이버의 추세가 비슷하고 삼성전자와 하이닉스의 추세가 비슷하다.<br /> 또한 각 기업별 주가 상승은 거래량에 영향을 미쳤을 것이고, 치솟는 거래량은 반대로 주가 상승 하락의 요인이 되었을 것이다.</p><p>즉, 복합적으로 8가지 지표는 서로 연관이 있겠다는 합리적인 가정을 할 수 있겠다.</p><h2 id="step-3-granger-인과검정">Step 3. Granger 인과검정</h2><p>VAR 예측을 수행하기 전에 해당 변수들이 모두 상호연관성이 있는가를 확인해줄 필요가 있다.<br /> Granger 인과검정의 영가설은 X가 Y에 영향을 미치지 않는다 이다. 즉, 검정 결과 p_value가 유의수준 0.05 이하라면 영가설을 기각하고 해당 변수를 예측모델의 인자로 사용하도록 한다.</p><p>각 변수가 서로 다른 변수에 영향을 주는가?를 검정하고, 검정 값(p-value)을 판다스 데이터프레임으로 한번에 표시할 것이다.</p><p>이를 위해 값을 저장할 데이터프레임을 만들어주자. 값은 우선 0으로 채운다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>df_pairs = pd.DataFrame(data=np.zeros((len(df_cols), len(df_cols))),
                        columns = ['X_'+x for x in df_cols],
                        index = ['Y_'+x for x in df_cols])
df_pairs
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-5.webp" alt="" /></p><p>다음으로 샘플을 확인하기 위해 2개 변수만 가지고 granger 인과검정을 실시해보자.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>from statsmodels.tsa.stattools import grangercausalitytests

df['kakao_ac'].diff()
sample_outs = grangercausalitytests(df[['kakao_ac','kakao_v']], maxlag=4)
print(sample_outs)
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-6.webp" alt="" /></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>type(sample_outs)
&gt;&gt; dict
</pre></table></code></div></div><p>sample_outs의 타입은 딕셔너리다. key와 value를 살펴보자.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>sample_outs.keys()
&gt;&gt; dict_keys([1, 2, 3, 4])
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>sample_outs.values()
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-7.webp" alt="" /></p><p>key는 최소 1부터 maxlen으로 지정한 4까지 존재하며, 각 값 내부에는 검정 결과가 들어있다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>sample_outs[1]
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-8.webp" alt="" /></p><p>f테스트, 카이제곱 등의 여러 검정통계량 결과값을 보여주고 있다. 우리는 이중 카이제곱 통계량을 사용하겠다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>sample_outs[1][0]['ssr_chi2test']
&gt;&gt; (0.04672946904650268, 0.8288552369555231, 1)
</pre></table></code></div></div><p>lag 1~4(day)까지의 p_value를 모두 확인해보면 다음과 값다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>[round(sample_outs[x][0]['ssr_chi2test'][1],2) for x in range(1,5)]
&gt;&gt;[0.83, 0.83, 0.89, 0.9]
</pre></table></code></div></div><p>여기서 p_value는 2번째 값, 0.82로 연관관계가 있다고 볼 수 없다. 즉, 영가설을 기각할 수 없다.</p><p>이제 다른 변수들의 상호 인과성을 함께 확인해보자. 단, 이번에는 4일치가 아닌 총 2주간(maxlag) 데이터로 결과값을 도출하도록 한다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>maxlag = 14
for col_i, col in enumerate(df_cols):
    for idx_i, idx in enumerate(df_cols):
        outs = grangercausalitytests(df[[col,idx]], maxlag=maxlag)
        pval_min = np.min([round(outs[x][0]['ssr_chi2test'][1],2) for x in range(1, maxlag+1)])
        df_pairs.iloc[idx_i, col_i] = pval_min
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-9.webp" alt="" /></p><p>(..이하 생략)</p><p>만들어진 데이터셋은 다음과 같다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>df_pairs
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-10.webp" alt="" /></p><p>더 뚜렷하게 보이도록 히트맵을 사용해 시각화를 수행한다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>import seaborn as sns

plt.figure(figsize=(16,8))
ax = sns.heatmap(df_pairs, annot=True, cmap='Blues')
ax.xaxis.tick_top()
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.show()
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-11.webp" alt="" /></p><p>앞에서 분석 대상 시차(maxlag)를 4일로 뒀을 때는 카카오 수정종가와 볼륨간 인과관계가 유의하지 않았으나 지금은 p_value가 유의수준 0.05 이하로 들어온다.<br /> 다른 변수들 역시 상당 수의 변수가 다른 변수로부터 영향을 받거나 주고 있는 것을 알 수 있다.<br /> 단, X와 Y간 영향관계가 항상 서로 주고받는 것은 아니라는 사실도 위 히트맵을 통해 확인할 수 있다. 예를 들어, 네이버 거래량(X_naver_v)은 카카오 수정종가(Y_kakao_ac)에 영향을 준다고 보기 어려운(p_value==0.49) 반면 카카오 수정종가(X_kakao_ac)는 네이버 거래량(Y_naver_v)에 유의한 영향을 준.</p><p>우리는 서로 영향을 주고 받는, 즉 상호 연관성이 있는 양방향 변수들만 VAR 모델 인자로 사용할 것이다.<br /> 이 조건에 만족하는 조합은 다음과 같다.</p><ul><li>[kakao_ac, kakao_v, naver_ac]<li>[kakao_v, naver_ac, naver_v]<li>[samsung_ac, samsung_v, skhy_ac]<li>…</ul><h2 id="step-4-cointegration-test">Step 4. Cointegration Test</h2><p>공적분 검정(혹은 요한슨 검정)은 다중 시계열 간 적분상 균형관계가 존재하는가를 판단한다.<br /> 즉, Granger 검정이 단일 시계열보다 다중 시계열로 설명력을 더 얻을수 있는가? 를 확인해주었다면, Cointegration 검정은 다중 시계열이 장기적 기간을 두고 안정적인 연관성을 보이는가? 를 확인해준다.<br /> 따라서 Granger 검정을 통해 필터링한 변수 조합 중 최적 조합을 찾기 위해 Cointegration 검정을 한번 더 실시하고자 한다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>from statsmodels.tsa.vector_ar.vecm import coint_johansen

sample_group = ['kakao_ac','kakao_v','naver_ac']
out = coint_johansen(df[sample_group], 1, 1)
out.lr1
&gt;&gt; array([453.97917988,   9.88834366,   1.92223596])
</pre></table></code></div></div><p>파이썬을 통해 공적분은 위와 같이 수행할 수 있다. 결과값으로 나온 수치는 각각 kakao_ac, kakao_v, naver_ac에 대한 공적분 통계량에 해당한다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>cvt_df = pd.DataFrame(out.cvt)
cvt_df.columns = ['90%', '95%', '99%']
cvt_df.index = sample_group
cvt_df
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-12.webp" alt="" /></p><p>out.cvt를 통해 각 유의수준에 해당하는 통계량을 확인할 수 있다. 공적분 결과값이 해당 유의수준 통계량보다 크다면(우측, 단측검정) 유의하다. 즉, 장기적으로 안정적인 연관성이 있다고 판단한다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>def calc_sig_dist(cols):
    out = coint_johansen(df[cols], 1, 1)
    stats = [round(x,2) for x in out.lr1]
    sigs = [round(x,2) for x in out.cvt[:, 1]]
    yns = [x&gt;y for x,y in zip(stats,sigs)]
    dist = np.mean(np.array(stats) - np.array(sigs))

    print('stats: ',stats)
    print('sig-level: ',sigs)
    print('significant_yn: ',[x&gt;y for x,y in zip(stats,sigs)])
    print('dist: ', round(dist,2))
</pre></table></code></div></div><p>stats는 공적분 통계량, sig-level은 유의수준 0.05에 해당하는 관측치, significant_yn은 유의 여부(장기 안정성), dist는 안정성의 강도를 의미한다.<br /> 함수를 통해 앞에서 묶은 그룹 3가지를 확인해보고, significant_yn이 모두 True이면서 dist가 가장 큰 그룹을 찾아보자.</p><p><img data-proofer-ignore data-src="/assets/images/posts/133-13.webp" alt="" /></p><p>결과값을 토대로 samsung_ac, samsung_v, skhy_v 3개 변수 조합을 사용하자.</p><h2 id="step-5-split-datasets-train--test">Step 5. Split Datasets (Train / Test)</h2><p>우리는 과거 데이터를 가지고 가장 최근 30일을 예측해보려 한다.<br /> 위에서 확인한 그룹을 추출해 최근 30일 전후로 데이터를 구분하자.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>target_lag = 30
target_df = df[['samsung_ac','samsung_v','skhy_v']]

df_train = target_df.iloc[:-target_lag, :]
df_test = target_df.iloc[-target_lag:, :]

print(df_train.shape, df_test.shape)
&gt;&gt; (3175, 3) (30, 3)
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-14.webp" alt="" /></p><h2 id="step-6-stationary-test">Step 6. Stationary Test</h2><p>마지막으로 VAR 모델을 만들기 전에 입력 데이터의 정상성을 확보해야 한다. 특히 수정종가의 경우 주가 특성상 추세를 포함할 것이므로 정상성을 띄지 않을 가능성이 매우 높다.<br /> (여기서 정상성이란 시간의 흐름에 관계없이 데이터의 평균 및 분산이 일정함을 의미하며 이러한 특성은 시계열 분석의 기본 전제가 된다.)</p><p>시계열 정상성은 Augmented Dickey-Fully(ADF) 검정을 통해 확인하도록 한다. 영가설은 정상성을 띄지 않는다 이다.<br /> ADF는 추세를 포함하는 시계열 데이터에 대해서도 단위근 검정을 실시해주는 방법론이며, Dickey-Fully(DF) 검정을 더욱 일반화시킨 방식이다.</p><p>samgsung_ac 데이터로 먼저 ADF 검정을 실시하고, 결과값 형태를 확인해보자.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>from statsmodels.tsa.stattools import adfuller

adf_sample = adfuller(df_train['samsung_ac'], autolag='AIC') # AIC가 가장 낮은 lag(시차)를 자동 선택
adf_sample
&gt;&gt; 
(-0.7808633243482267,
 0.8246787955943002,
 28,
 3146,
 {'1%': -3.432430306322329,
  '5%': -2.862459151265583,
  '10%': -2.567259285721503},
 49407.65034169026)
</pre></table></code></div></div><p>보기 편하게 데이터프레임으로 변환해보자.<br /> p_value가 0.05보다 작은가, 즉 인덱스 기준 stat이 5% 유의구간 내에 들어가는가를 확인하면 된다.<br /> 결과값에서 알 수 있듯이 좌측 단측검정이다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>adf_df = pd.DataFrame(adf_sample[:4])
adf_df.columns = ['samsung_ac']
adf_df.index = ['stat','p_value','lag','observ']

sig = pd.DataFrame(data={'samsung_ac':adf_sample[4]['5%']}, index=['5%'])
adf_df = pd.concat([adf_df, sig], axis=0)
adf_df
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-15.webp" alt="" /></p><p>samsung_ac의 경우 stat이 5% 보다 크다. 따라서 영가설을 기각할 수 없다.<br /> 마찬가지로 나머지 2개 변수도 ADF 검정을 실시한다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>def get_adf_df(data):
    adf_df = pd.DataFrame(adfuller(data, autolag='AIC')[:4])
    adf_df.columns = [col]
    adf_df.index = ['stat','p_value','lag','observ']

    sig = pd.DataFrame(data={col:adf_sample[4]['5%']}, index=['5%'])
    adf_df = pd.concat([adf_df, sig], axis=0)
    adf_df = adf_df.apply(lambda x : round(x, 2))
    return adf_df
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-16.webp" alt="" /></p><p>거래량을 나타내는 samsung_v와 skhy_v는 정상성을 만족한다. 따라서 우리는 VAR 모델링을 위해 samsung_ac만 정상성을 만족시켜주면 되겠다.</p><p>차분을 통해 간단히 분포를 바꿔주고 정상성을 다시 확인한다.<br /> (차분을 수행하면 첫번째 인덱스는 nan값으로 바뀐다. bfill()함수를 통해 두번째 값으로 첫번째 값을 채워주겠다.)</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>get_adf_df(df_train['samsung_ac'].diff().bfill())
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-17.webp" alt="" /></p><p>1회 차분으로 samsung_ac 변수도 정상성을 확보했다. 이제 모델을 만들어보자.</p><h2 id="step-7-var">Step 7. VAR</h2><p>VAR 모델 역시 파이썬 함수를 통해 간단히 구현가능하다. 앞에서 1회 차분이 정상성을 확보시켜주는 것을 확인했으므로 해당 데이터만 치환한 후 데이터를 인자로 넘겨주겠다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>df_train_ = df_train.drop('samsung_ac', axis=1).copy()
df_train_['samsung_ac_diff'] = df_train['samsung_ac'].diff().bfill()
df_train_
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-18.webp" alt="" /></p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>from statsmodels.tsa.api import VAR

var = VAR(df_train_)
var.select_order(maxlags=30).summary()
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-19.webp" alt="" /></p><p>AIC가 10 이상만 되어도 유의한 예측이라고 보기 어렵다.<br /> 물론 데이터를 더 가공하고 양질의 연관 변수를 추가해볼 수도 있겠지만 이 경우는 기본 값 자체가 매우 커서 그렇다.<br /> 데이터 범위가 커서 예측 수준이 떨어지는 것이다.</p><p>따라서 데이터를 한번 더 처리해주겠다. 이번에는 정규화를 시켜줄텐데, 시계열 데이터의 경우 정규화에 주의해야 한다.<br /> 예측값이 최근 일자, 관측값이 과거 일자이므로 정규화가 최근 일자 예측에 어떠한 영향도 미쳐선 안된다. 예를 들어, 전체 데이터를 min-max-scailing한다거나 하는 식으로 말이다.<br /> 우리는 전체 평균이 아니라 첫날 데이터를 0으로 기준을 잡고, 그 이후에는 첫날 대비 변화량을 보려줄 수 있도록 할 것이다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>df_train_norm = (df_train_ / df_train_.iloc[0]) - 1
df_train_norm
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-20.webp" alt="" /></p><p>데이터를 한번 더 처리했으니 정상성 여부도 체크해준다.<br /> 참고로, 일반적으로 정제 강도가 커질수록 정보가 희석되고 정상성이 커지므로 정상 데이터가 비정상으로 다시 회귀하는 경우는 잘 없다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>print(get_adf_df(df_train_norm['samsung_ac_diff']).loc['p_value'])
print(get_adf_df(df_train_norm['samsung_v']).loc['p_value'])
print(get_adf_df(df_train_norm['skhy_v']).loc['p_value'])

&gt;&gt;
skhy_v    0.0
Name: p_value, dtype: float64
skhy_v    0.0
Name: p_value, dtype: float64
skhy_v    0.01
Name: p_value, dtype: float64
</pre></table></code></div></div><p>이제 다시 VAR 모델에 데이터를 태워준다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>var_norm = VAR(df_train_norm)
var_norm.select_order(maxlags=20).summary()
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-21.webp" alt="" /></p><p>일반적으로 AIC 기준 2.0 이하는 모델이 타당하다고 할 수 있다.<br /> 모델은 과거 1주일치 데이터만 가지고도 어느 정도의 성능을 보이고 있으며, 예측 정확도는 2주 데이터가 확보되었을 때 가장 높았다.<br /> 따라서 모델의 시차(lag)를 2주로 적합시킨다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>model = var_norm.fit(14)
model.summary()
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-22.webp" alt="" /></p><p>(..중략)</p><p><img data-proofer-ignore data-src="/assets/images/posts/133-23.webp" alt="" /></p><p>summary에서 중요한 부분은 마지막 Correlation matrix다.<br /> 해당 관측치는 변수 잔차간 상관관계인데, 이 수치가 크다면 아직 고려해야 할 요소들이 남아있는 것이며 모델은 충분한 설명력을 갖추지 못했다고 볼 수 있다.</p><p>Correlation matrix는 이는 다음과 같이 직접 추출할 수 있다.</p><p><img data-proofer-ignore data-src="/assets/images/posts/133-24.webp" alt="" /></p><p>다만, 이렇게 봤을 때 이것이 유의한 수준인지 그렇지 않은지 확인할 수 없으므로 마찬가지로 검정통계를 실시한다.<br /> 잔차의 독립성 검정은 Durbin Watson 검정을 통해 수행하도록 하자.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>from statsmodels.stats.stattools import durbin_watson

durbin_res = pd.DataFrame([model.resid.columns, 
                           [round(x,2) for x in durbin_watson(model.resid)]]).T
durbin_res.set_index([0])
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-25.webp" alt="" /></p><p>Durbin Watson 검정은 다음과 같이 해석한다.</p><ul><li>범위 : 0~4<li>양의 상관관계 : 0에 수렴<li>음의 상관관계 : 4에 수렴<li>상관관계 없음 : 2에 수렴</ul><p>위 해석에 따라 본 모델은 잔차간 상관성이 유의하지 않은 수준이며, 충분한 예측 설명력을 갖췄음을 확인할 수 있다.</p><h2 id="step-8-forecast">Step 8. Forecast</h2><p>우리가 만든 모델의 lag는 예측을 위해 사용할 데이터 범위가 된다. 즉, 과거 14일치 데이터를 가지고 앞으로의 주가를 예측한다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>model.k_ar
&gt;&gt; 14
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>ins = df_train_norm.values[-model.k_ar:]
ins
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-26.webp" alt="" /></p><p>3개 변수에 대한 최근 14일치의 데이터다. 앞에서 우리는 최근 30일치를 기준으로 train dataset를 나눴기 때문에 30일치보다 앞선 14일치 데이터라고 보면 되겠다.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>f = model.forecast(y=ins, steps=7)
df_f = pd.DataFrame(f, columns=df_train_norm.columns)
df_f
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-27.webp" alt="" /></p><p>forecast 함수를 사용해 df_train 기준 마지막 14개 행의 데이터로 다음 7개 행을 예측했다.<br /> 예측한 값을 실제 값과 비교하기 위해서는 실제 값의 분포로 다시 돌려줘야 한다.</p><p>먼저 전체 데이터셋에 대해 첫번째 행 데이터 기준 정규화를 해줬으니 반대로 역정규화를 시켜주자.</p><p><img data-proofer-ignore data-src="/assets/images/posts/133-28.webp" alt="" /></p><p>다음 단계는 1차 차분시킨 samsung_ac_diff도 원상 복귀시키는 것이다.<br /> 학습데이터 기준, 마지막 날부터 누적합을 통해 계산할 수 있다.</p><p><img data-proofer-ignore data-src="/assets/images/posts/133-29.webp" alt="" /> <img data-proofer-ignore data-src="/assets/images/posts/133-30.webp" alt="" /></p><p>마지막으로, 테스트 데이터셋과 동일한 시계열상에 올려주자.</p><p><img data-proofer-ignore data-src="/assets/images/posts/133-31.webp" alt="" /></p><p>데이터셋이 준비되었으므로 예측값과 실제값을 시각화를 통해 비교해보도록 하자.</p><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre>def draw_subplot(axes, ax_i, col):
    d_test = df_test[col].iloc[:7]
    d_pred = df_f_denorm[col]
    
    d_test.diff() &gt; 0
    
    axes[ax_i].plot(d_test, label='real')
    axes[ax_i].plot(d_pred, label='pred')
    
    hits = (d_test.diff() &lt; 0) == (d_pred.diff() &lt; 0)
    for i, hit in enumerate(hits):
        if hit:
            if i==0:
                pass
            if i+1==len(hits):
                i==None
            axes[ax_i].fill_between(x=d_test.index[i-1:i+1], 
                                    y1=d_pred[i-1:i+1],
                                    y2=d_test[i-1:i+1], 
                                    color='lightpink', 
                                    alpha=0.1)       
    axes[ax_i].set_title(col)
    axes[ax_i].legend(loc=(1,1))
</pre></table></code></div></div><div class="language-plaintext highlighter-rouge"><div class="code-header"> <span text-data=" Text "><i class="fa-fw fas fa-code small"></i></span> <button aria-label="copy" title-succeed="Copied!"><i class="far fa-clipboard"></i></button></div><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>fig, axes = plt.subplots(nrows=3, ncols=1, figsize=(10,10))

draw_subplot(axes, 0, 'samsung_ac')
draw_subplot(axes, 1, 'samsung_v')
draw_subplot(axes, 2, 'skhy_v')

plt.tight_layout()
plt.show()
</pre></table></code></div></div><p><img data-proofer-ignore data-src="/assets/images/posts/133-32.webp" alt="" /></p><p>이렇게 7일간의 데이터 예측치를 살펴보았고, 상승 및 하락 여부가 일치하는 구간에는 영역을 채워줬다. 위 결과값만 놓고 보면 VAR 모형이 종가 예측보다는 거래량 예측에 더 나은 성능을 내는 것으로 보이며 추세도 어느 정도 잘 판단해내는 듯 하다.</p><p>만약 이 모델에 대한 정량적 평가를 실시해보고 싶다면 다음의 순서를 따르면 되겠다.</p><ol><li>14일치 데이터셋을 최소 30개 이상 확보한다.<li>각 데이터셋(배치)에 대한 7일간 예측치과 실제값의 오차를 RMSE 등의 방식으로 계산한다.</ol><p>다만, 주가데이터 특성상 종가의 범위가 주식마다 매우 다르기 때문에 상승 및 하락에 대한 예측정확도를 평가하는 것도 하나의 방법이며 방식은 다음과 같다.</p><ol><li>모형 결과로 나온 값을 차분한다.<li>차분 값을 음수와 양수를 2개 클래스로 나눈다.(위 시각화에서도 상승하락 여부가 같은지 유사한 프로세스로 비교하였다.)<li>실제 데이터도 동일하게 차분 및 이진화로 라벨링을 수행한 후 f1 스코어 등으로 평가한다.</ol><p>지금까지 이렇게 VAR 모형의 간단한 개념을 알아보고, 모형을 사용하기 위한 통계적 검정들도 수행한 뒤, 모델링 및 예측까지 시도해보았다.</p><p><strong>관성을 이기는 데이터</strong></p><p><a href="https://creativecommons.org/licenses/by/4.0/deed.ko">저작자표시 (새창열림)</a></p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/3-%ED%8A%9C%ED%86%A0%EB%A6%AC%EC%96%BC/'>3. 튜토리얼</a>, <a href='/categories/%EC%8B%9C%EA%B3%84%EC%97%B4-%EC%98%88%EC%B8%A1-%EB%B0%8F-%EA%B3%84%EB%9F%89-%EB%B6%84%EC%84%9D-%EB%B0%A9%EB%B2%95%EB%A1%A0/'>시계열 예측 및 계량 분석 방법론</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/"> CC BY 4.0 </a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=벡터자기회귀 모형(VAR)을 활용한 다변량 예측 모델링 - 국내 주요 기업 주가 및 거래량 예측 - 관성을 이기는 데이터&url=https://sw-song.github.io/posts/%EB%B2%A1%ED%84%B0%EC%9E%90%EA%B8%B0%ED%9A%8C%EA%B7%80-%EB%AA%A8%ED%98%95-VAR-%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%8B%A4%EB%B3%80%EB%9F%89-%EC%98%88%EC%B8%A1-%EB%AA%A8%EB%8D%B8%EB%A7%81-%EA%B5%AD%EB%82%B4-%EC%A3%BC%EC%9A%94-%EA%B8%B0%EC%97%85-%EC%A3%BC%EA%B0%80-%EB%B0%8F-%EA%B1%B0%EB%9E%98%EB%9F%89/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=벡터자기회귀 모형(VAR)을 활용한 다변량 예측 모델링 - 국내 주요 기업 주가 및 거래량 예측 - 관성을 이기는 데이터&u=https://sw-song.github.io/posts/%EB%B2%A1%ED%84%B0%EC%9E%90%EA%B8%B0%ED%9A%8C%EA%B7%80-%EB%AA%A8%ED%98%95-VAR-%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%8B%A4%EB%B3%80%EB%9F%89-%EC%98%88%EC%B8%A1-%EB%AA%A8%EB%8D%B8%EB%A7%81-%EA%B5%AD%EB%82%B4-%EC%A3%BC%EC%9A%94-%EA%B8%B0%EC%97%85-%EC%A3%BC%EA%B0%80-%EB%B0%8F-%EA%B1%B0%EB%9E%98%EB%9F%89/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=벡터자기회귀 모형(VAR)을 활용한 다변량 예측 모델링 - 국내 주요 기업 주가 및 거래량 예측 - 관성을 이기는 데이터&url=https://sw-song.github.io/posts/%EB%B2%A1%ED%84%B0%EC%9E%90%EA%B8%B0%ED%9A%8C%EA%B7%80-%EB%AA%A8%ED%98%95-VAR-%EC%9D%84-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%8B%A4%EB%B3%80%EB%9F%89-%EC%98%88%EC%B8%A1-%EB%AA%A8%EB%8D%B8%EB%A7%81-%EA%B5%AD%EB%82%B4-%EC%A3%BC%EC%9A%94-%EA%B8%B0%EC%97%85-%EC%A3%BC%EA%B0%80-%EB%B0%8F-%EA%B1%B0%EB%9E%98%EB%9F%89/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i id="copy-link" class="fa-fw fas fa-link small" data-toggle="tooltip" data-placement="top" title="Copy link" title-succeed="Link copied successfully!"> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Tistory%EC%97%90%EC%84%9C-GitHub-Pages%EB%A1%9C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%A7%88%EC%9D%B4%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%85%98-%EC%99%84%EC%A0%84-%EA%B0%80%EC%9D%B4%EB%93%9C/">Tistory에서 GitHub Pages로 블로그 마이그레이션 완전 가이드</a><li><a href="/posts/JavaScript-%EC%BD%9C%EB%B0%B1/">JavaScript - 콜백</a><li><a href="/posts/JavaScript-%EA%B0%9D%EC%B2%B4-%EC%B0%B8%EC%A1%B0-assign/">JavaScript - '객체 참조', assign()</a><li><a href="/posts/%EB%A7%A5-Mac-%ED%84%B0%EB%AF%B8%EB%84%90-%EA%B2%BD%EB%A1%9C%EC%84%A4%EC%A0%95-%EC%95%84%EB%82%98%EC%BD%98%EB%8B%A4-Anaconda-2020%EB%85%84-5%EC%9B%94-10%EC%9D%BC-%EA%B8%B0%EC%A4%80/">맥(Mac) 터미널 경로설정 - 아나콘다(Anaconda), 2020년 5월 10일 기준 updated</a><li><a href="/posts/%EB%A7%A5-zsh-conda-install-%EC%97%90%EB%9F%AC-pip-install%EB%A1%9C-%EB%8C%80%EC%B2%B4/">맥 zsh - conda install 에러, pip install로 대체</a></ul></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%EA%B3%BC%EA%B1%B0-%EC%A3%BC%EA%B0%80-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A1%9C-%EB%AF%B8%EB%9E%98-%EC%A3%BC%EA%B0%80%EB%A5%BC-%EC%98%88%EC%B8%A1%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EC%8B%9C%EA%B3%84%EC%97%B4-%ED%8C%A8%ED%84%B4-%EA%B2%80%EC%83%89/"><div class="card-body"> <span class="timeago small" >Sep 16, 2021<i class="unloaded">2021-09-16T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>과거 주가 데이터로 미래 주가를 예측할 수 있을까? - 파이썬 시계열 패턴 검색</h3><div class="text-muted small"><p> Step 0. 패턴 검색 이번에는 현재 차트와 유사한 차트를 찾아서 매매에 활용하는 패턴 검색을 파이썬으로 구현해보자. 패턴 검색은 과거 주가에서 현재 주가와 유사한 패턴을 관측한 다음, 과거 주가 이후의 흐름을 확인하는 것을 통해 앞으로의 주가를 예상해보는 방식이다. Step 1. 코스피 종가 가져오기 2010년부터 현재까지의 데이터를 스크리닝...</p></div></div></a></div><div class="card"> <a href="/posts/JavaScript-6-%EC%9B%90%EC%B9%99/"><div class="card-body"> <span class="timeago small" >Oct 5, 2019<i class="unloaded">2019-10-05T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>JavaScript - 6 원칙</h3><div class="text-muted small"><p> 우아한형제들 김민태님의 ‘자바스크립트 부트캠프(패스트캠퍼스)’ 수강 중, 허가를 받고 정리한 내용입니다. 1. 코드 중간중간에 데이터를 넣지 마라.   코드는 읽는 시간이 작성하는 시간보다 훨씬 길다. 따라서 읽고 이해하기 쉽게 데이터는 데이터대로 따로 배치하는 것이 좋다. 그래서 간단한 수식 하나라도 변수를 통해, 네이밍을 해주는 것이 중...</p></div></div></a></div><div class="card"> <a href="/posts/JavaScript-%EA%B0%9D%EC%B2%B4%EC%99%80-%EB%8F%99%EC%A0%81-%EB%B0%94%EC%9D%B8%EB%94%A9-%EA%B0%92%EC%9D%98-%EC%9D%B4%EB%8F%99/"><div class="card-body"> <span class="timeago small" >Oct 8, 2019<i class="unloaded">2019-10-08T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>JavaScript - 객체와 동적 바인딩, 값의 이동</h3><div class="text-muted small"><p> 객체란   객체는 데이터를 표현하는 도구이면서 현실의 구체적 대상을 추상적으로 묘사하기 위해 사용된다. 코드는 언제나 현실의 추상화 작업을 거치게 되는데, 추상화란 보여주고자 하는 핵심적인 요소 이외의 것들은 모두 은폐하는 것을 말한다. 복잡한 현실세계를 모두 코드로 표현할 수 없을뿐더러 표현했다 하더라도 그것을 읽는 것은 불가능하다. 따라서 추상화...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%EA%B8%88%EC%9C%B5-%EB%B6%84%EC%84%9D%EC%9D%84-%EC%9C%84%ED%95%9C-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%B3%B4%EC%B6%A9%EC%9E%90%EB%A3%8C-02-%ED%8C%8C%EC%9D%B4%EC%8D%AC-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%8B%9C%EA%B3%84%EC%97%B4-%EC%B0%A8%ED%8A%B8-%EC%8B%9C%EA%B0%81%ED%99%94/" class="btn btn-outline-primary" prompt="Older"><p>금융 분석을 위한 파이썬 프로그래밍 - 보충자료 02. 파이썬 데이터 시계열 차트 시각화(matplotlib, subplots)</p></a> <a href="/posts/%EB%8B%A8%EC%96%B4%EC%9D%98-%EC%9D%98%EB%AF%B8%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%9C-%EB%AC%B8%EC%9E%A5-%EC%9C%A0%EC%82%AC%EB%8F%84-%EC%B8%A1%EC%A0%95-%EB%B0%A9%EB%B2%95-%EA%B8%B0%EC%A0%80-%EB%B2%A1%ED%84%B0%EC%99%80-%EC%84%A0%ED%98%95-%EB%B3%80%ED%99%98/" class="btn btn-outline-primary" prompt="Newer"><p>단어의 의미를 고려한 문장 유사도 측정 방법 - 기저 벡터와 선형 변환</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://github.com/sw-song">Seungwon Song</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
